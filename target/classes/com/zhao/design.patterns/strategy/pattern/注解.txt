策咯模式：
    它属于对象的行为模式，用意使针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得他们可以相互替换。策略模式使用算法可以在不影响到客户端的情况下发生变化。


策略模式的结构：
    对算法的包装，是把使用算法的责任和算法本身分割开，委托给不同的对象进行管理，它通常是把一个系列的算法包装到一系列的策略类中。有以下三种角色。
    1、环境角色：持有一个Strategy的引用。
    2、抽象策略角色：是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需要的接口。
    3、具体策略角色：包装了相关的算法或行为。

策略模式的重心：
    它的重心不是如何实现算法，而是如何组织、调用这些算法，从而使程序结构更加灵活，具有更好的维护性和扩展性。
算法的平等性
    策略模式一个很大的特点就是各个策略算法的平等性。在当中大家的地位使完全一样的，因为这个平等性，实现了算法之间可以相互替换。并且策略算法在实现上使相互独立，相互之间没有依赖的。
    可以总结为：策略算法是相同行为的不同实现。
运行时策略的唯一性
    运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象。虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。
公有的行为
    经常看到的是，所有的具体策略类都有一些公有的行为。就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。这个抽象策略角色必须要用Java抽象类实现，不能使用接口。



策略模式的优点：
    策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当的使用 继承可以把公共的代码移到父类里面，可以避免代码重复。
    使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不容易维护，它把采取那一中算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。


策略模式的缺点：
    客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。要不，策略模式只适用于客户端知道的算法或行为的情况。
    由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很多。



通俗的说以及个人理解：
    策略模式首先要把策略方法，如IStrategy这个父类定义好，下面有多少个策略，就继承父类，然后一个一个实现相应的策咯，Context这个类主要是你想用那个策略，然后在里面执行相应的方法。









