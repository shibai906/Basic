原型模式：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。它是一种创建型模式。

工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的，原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。

需要注意的是通过克隆方法所创建的对象是全新的对象，它们了内存中拥有新的地址，通过对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的，通过不同的方式修改可以得到一系列相似但不完全相同的对象

原型模式结构图有以下几个角色：
1、Prototype(抽象原型类)：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。
2、ConcretePrototype(具体原型类)：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。
3、Client(客户类)：让一个原型对象克隆自身而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，在通过调用该对象的克隆方法即可得到多个相同的对象，由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有良好的可扩展性，增加或更换具体原型类也很方便。


原型模式的主要优点如下：
    1、当创建新对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有的实例可以提高新实例的创建效率。
    2、扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类型进行编程，而将具体原型类卸载配置文件中，增加或减少产品类对原有系统都没有任何影响。
    3、原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制时通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
    4、可以使用深克隆的方式来保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，可辅助实现撤销操作。

主要缺点：
    1、需要为每一个类配置一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。
    2、在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能比较麻烦。


适用场景：
    1、创建新对象成本比较大(初始化需要占用较长时间，占用太多的CPU资源或者网络资源)，新的对象可以通过原型模式对已有对象进行复制来获得，如果相似对象，则可以对期成员变量稍作修改即可。
    2、如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。
    3、需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制对象得到新实例可能比使用构造函数创建一个新实例更加方便。


深克隆和浅克隆：
    1、浅克隆：如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量只想相同的内存地址，简单来说，在浅克隆中，等对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。
    2、深克隆：无论原型对象的成员变量是值类型还是引用类型，都将复制一份克隆对象，深克隆将原型对象的所有引用对象复制一份给克隆对象。在Java中，需要实现深克隆，可通过序列化等方式来实现，序列化将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而元对象仍然存在于内存中，通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其都出来，可以实现深克隆。







