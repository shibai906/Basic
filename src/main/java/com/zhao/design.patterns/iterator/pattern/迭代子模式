迭代子模式：
    又叫游标模式，是对象的行为模式。迭代子模式可以顺序地访问一个剧集中的元素而不必暴漏聚集的内部表象。
聚集和JAVA聚集
    多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。

    迭代子模式结构
        迭代子模式有两种实现方式，分别是白箱聚集与外禀迭代子和黑箱聚集于内禀迭代子。


白箱聚集与外禀迭代子
    如果一个聚集的接口提供了可以用来修改聚集元素的方法，这就是所谓的宽接口。

    如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求，但是，这样会破环对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口。
    由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做游标迭代子。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子。
    因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。

迭代子模式涉及到以下几个角色:
    1、抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。
    2、具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。
    3、聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。
    4、具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合格的具体迭代子实例。
    5、客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的接口，也有可能通过迭代子操作聚集元素的增加和删除。
    个人理解这个就是一个是抽象，主要用来存储东西的，它有一个存储东西的接口，然后子类实现，并实现相应的功能，另一个接口是用来取出东西，它的子类就是实现这些功能。
外禀迭代子的意义：
    客户端可以自行进行迭代，不一定非得需要一个迭代子对象。但是，迭代子对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代子责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代子作为一个中阶层可以吸收变化的因素，从而避免修改客户端或者聚集本身。
    此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代子模式和一个外界的迭代子对象是有意义的，具有同一迭代接口的不同迭代子对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。

黑箱聚集与内禀迭代子
    如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的窄接口。
    聚集对象为迭代子对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代子对象适当公开，以便迭代子对象能够对聚集对象有足够的了解，从而可以进行迭代操作，但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代子对象进行这些工作，而不是直接操控聚集对象。
    在Java中，实现双重接口的办法就是将迭代子类设计成聚集类的内部成员类，这样迭代子对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构，下面给出一个示意性的实现，说明这种双重接口的结构是怎么产生的，以及使用了双重接口结构之后迭代子模式的实现方案。这种同时保证聚集对象的封装和迭代子功能的实现的方案叫做黑箱实现方案。
    由于迭代子是聚集的内部类，迭代子可以自由访问聚集的元素，所以迭代子可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代子是在聚集的结构之内定义的，因此这样的迭代子又叫做内禀迭代子。


内禀和外禀的主要区别在于，内禀迭代对象是内部类，外禀迭代对象是外部类

主动迭代子和被动迭代子
    主动迭代子和被动迭代子又称作外部迭代子和内部迭代子。
    主动(外部)迭代子，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显蝶泳迭代子的next()等方法，在遍历过程中向前进行。
    被动(内部)迭代子，指的是由迭代子自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代子，迭代子在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。
    总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代子。

迭代子模式的优点：
    1、迭代子模式简化了聚集的接口。迭代子具备了一个遍历的接口，这样聚集的接口就不必具备遍历接口。
    2、每一个聚集对象都可以有一个或多个迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此一个聚集对象可以同时有几个迭代在进行之中。
    3、由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。















